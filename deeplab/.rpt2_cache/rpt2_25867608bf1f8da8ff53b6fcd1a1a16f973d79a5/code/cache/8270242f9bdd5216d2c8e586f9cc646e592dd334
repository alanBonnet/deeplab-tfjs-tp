{"code":"/**\r\n * @license\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport * as tslib_1 from \"tslib\";\r\nimport * as tf from '@tensorflow/tfjs-core';\r\nimport { config } from './config';\r\nexport function createPascalColormap() {\r\n    /**\r\n     * Generates the colormap matching the Pascal VOC dev guidelines.\r\n     * The original implementation in Python: https://git.io/fjgw5\r\n     */\r\n    var pascalColormapMaxEntriesNum = config['DATASET_MAX_ENTRIES']['PASCAL'];\r\n    var colormap = new Array(pascalColormapMaxEntriesNum);\r\n    for (var idx = 0; idx < pascalColormapMaxEntriesNum; ++idx) {\r\n        colormap[idx] = new Array(3);\r\n    }\r\n    for (var shift = 7; shift > 4; --shift) {\r\n        var indexShift = 3 * (7 - shift);\r\n        for (var channel = 0; channel < 3; ++channel) {\r\n            for (var idx = 0; idx < pascalColormapMaxEntriesNum; ++idx) {\r\n                colormap[idx][channel] |= ((idx >> (channel + indexShift)) & 1)\r\n                    << shift;\r\n            }\r\n        }\r\n    }\r\n    return colormap;\r\n}\r\n/**\r\n * Returns\r\n *\r\n * @param base  :: `ModelArchitecture`\r\n *\r\n * The type of model to load (either `pascal`, `cityscapes` or `ade20k`).\r\n *\r\n * @param quantizationBytes (optional) :: `QuantizationBytes`\r\n *\r\n * The degree to which weights are quantized (either 1, 2 or 4).\r\n * Setting this attribute to 1 or 2 will load the model with int32 and\r\n * float32 compressed to 1 or 2 bytes respectively.\r\n * Set it to 4 to disable quantization.\r\n *\r\n * @return The URL of the TF.js model\r\n */\r\nexport function getURL(base, quantizationBytes) {\r\n    var TFHUB_BASE = \"\" + config['BASE_PATH'];\r\n    var TFHUB_QUERY_PARAM = 'tfjs-format=file';\r\n    var modelPath = quantizationBytes === 4 ?\r\n        base + \"/1/default/1/model.json\" :\r\n        base + \"/1/quantized/\" + quantizationBytes + \"/1/model.json\";\r\n    // Example of url that should be generated.\r\n    // https://tfhub.dev/tensorflow/tfjs-model/deeplab/pascal/1/default/1/model.json?tfjs-format=file\r\n    return TFHUB_BASE + \"/\" + modelPath + \"?\" + TFHUB_QUERY_PARAM;\r\n}\r\n/**\r\n * @param base  :: `ModelArchitecture`\r\n *\r\n * The type of model to load (either `pascal`, `cityscapes` or `ade20k`).\r\n *\r\n * @return colormap :: `[number, number, number][]`\r\n *\r\n * The list of colors in RGB format, represented as arrays and corresponding\r\n * to labels.\r\n */\r\nexport function getColormap(base) {\r\n    if (base === 'pascal') {\r\n        return config['COLORMAPS']['PASCAL'];\r\n    }\r\n    else if (base === 'ade20k') {\r\n        return config['COLORMAPS']['ADE20K'];\r\n    }\r\n    else if (base === 'cityscapes') {\r\n        return config['COLORMAPS']['CITYSCAPES'];\r\n    }\r\n    throw new Error(\"SemanticSegmentation cannot be constructed \" +\r\n        (\"with an invalid base model \" + base + \". \") +\r\n        \"Try one of 'pascal', 'cityscapes' and 'ade20k'.\");\r\n}\r\n/**\r\n * @param base  :: `ModelArchitecture`\r\n *\r\n * The type of model to load (either `pascal`, `cityscapes` or `ade20k`).\r\n *\r\n * @return labellingScheme :: `string[]`\r\n *\r\n * The list with verbal descriptions of labels\r\n */\r\nexport function getLabels(base) {\r\n    if (base === 'pascal') {\r\n        return config['LABELS']['PASCAL'];\r\n    }\r\n    else if (base === 'ade20k') {\r\n        return config['LABELS']['ADE20K'];\r\n    }\r\n    else if (base === 'cityscapes') {\r\n        return config['LABELS']['CITYSCAPES'];\r\n    }\r\n    throw new Error(\"SemanticSegmentation cannot be constructed \" +\r\n        (\"with an invalid base model \" + base + \". \") +\r\n        \"Try one of 'pascal', 'cityscapes' and 'ade20k'.\");\r\n}\r\n/**\r\n * @param input  ::\r\n * `ImageData|HTMLImageElement|HTMLCanvasElement| HTMLVideoElement|tf.Tensor3D`\r\n *\r\n * The input image to prepare for segmentation.\r\n *\r\n * @return resizedInput :: `string[]`\r\n *\r\n * The input tensor to run through the model.\r\n */\r\nexport function toInputTensor(input) {\r\n    return tf.tidy(function () {\r\n        var image = input instanceof tf.Tensor ? input : tf.browser.fromPixels(input);\r\n        var _a = image.shape, height = _a[0], width = _a[1];\r\n        var resizeRatio = config['CROP_SIZE'] / Math.max(width, height);\r\n        var targetHeight = Math.round(height * resizeRatio);\r\n        var targetWidth = Math.round(width * resizeRatio);\r\n        return tf.expandDims(tf.image.resizeBilinear(image, [targetHeight, targetWidth]));\r\n    });\r\n}\r\n/**\r\n * @param colormap :: `Color[]`\r\n *\r\n * The list of colors in RGB format, represented as arrays and corresponding\r\n * to labels.\r\n *\r\n * @param labellingScheme :: `string[]`\r\n *\r\n * The list with verbal descriptions of labels\r\n *\r\n * @param rawSegmentationMap :: `tf.Tensor2D`\r\n *\r\n * The segmentation map of the image\r\n *\r\n * @param canvas (optional) :: `HTMLCanvasElement`\r\n *\r\n * The canvas where to draw the output\r\n *\r\n * @returns A promise of a `DeepLabOutput` object, with four attributes:\r\n *\r\n * - **legend** :: `{ [name: string]: [number, number, number] }`\r\n *\r\n *   The legend is a dictionary of objects recognized in the image and their\r\n *   colors in RGB format.\r\n *\r\n * - **height** :: `number`\r\n *\r\n *   The height of the returned segmentation map\r\n *\r\n * - **width** :: `number`\r\n *\r\n *   The width of the returned segmentation map\r\n *\r\n * - **segmentationMap** :: `Uint8ClampedArray`\r\n *\r\n *   The colored segmentation map as `Uint8ClampedArray` which can be\r\n *   fed into `ImageData` and mapped to a canvas.\r\n */\r\nexport function toSegmentationImage(colormap, labelNames, rawSegmentationMap, canvas) {\r\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n        var _a, height, width, segmentationImageBuffer, mapData, labels, columnIndex, rowIndex, label, segmentationImageTensor, segmentationMap, legend, _i, _b, label;\r\n        return tslib_1.__generator(this, function (_c) {\r\n            switch (_c.label) {\r\n                case 0:\r\n                    if (colormap.length < labelNames.length) {\r\n                        throw new Error('The colormap must be expansive enough to encode each label. ' +\r\n                            (\"Aborting, since the given colormap has length \" + colormap.length + \", \") +\r\n                            (\"but there are \" + labelNames.length + \" labels.\"));\r\n                    }\r\n                    _a = rawSegmentationMap.shape, height = _a[0], width = _a[1];\r\n                    segmentationImageBuffer = tf.buffer([height, width, 3], 'int32');\r\n                    return [4 /*yield*/, rawSegmentationMap.array()];\r\n                case 1:\r\n                    mapData = _c.sent();\r\n                    labels = new Set();\r\n                    for (columnIndex = 0; columnIndex < height; ++columnIndex) {\r\n                        for (rowIndex = 0; rowIndex < width; ++rowIndex) {\r\n                            label = mapData[columnIndex][rowIndex];\r\n                            labels.add(label);\r\n                            segmentationImageBuffer.set(colormap[label][0], columnIndex, rowIndex, 0);\r\n                            segmentationImageBuffer.set(colormap[label][1], columnIndex, rowIndex, 1);\r\n                            segmentationImageBuffer.set(colormap[label][2], columnIndex, rowIndex, 2);\r\n                        }\r\n                    }\r\n                    segmentationImageTensor = segmentationImageBuffer.toTensor();\r\n                    return [4 /*yield*/, tf.browser.toPixels(segmentationImageTensor, canvas)];\r\n                case 2:\r\n                    segmentationMap = _c.sent();\r\n                    tf.dispose(segmentationImageTensor);\r\n                    legend = {};\r\n                    for (_i = 0, _b = Array.from(labels); _i < _b.length; _i++) {\r\n                        label = _b[_i];\r\n                        legend[labelNames[label]] = colormap[label];\r\n                    }\r\n                    return [2 /*return*/, { legend: legend, segmentationMap: segmentationMap }];\r\n            }\r\n        });\r\n    });\r\n}\r\n//# sourceMappingURL=utils.js.map","references":["C:/Users/Alan Bonnet/Desktop/Clasess/tensor/Trabajo grpal/TODOS_LOS_MODELOS/tfjs-models/deeplab/node_modules/@tensorflow/tfjs-core/dist/index.d.ts","C:/Users/Alan Bonnet/Desktop/Clasess/tensor/Trabajo grpal/TODOS_LOS_MODELOS/tfjs-models/deeplab/src/config.ts","C:/Users/Alan Bonnet/Desktop/Clasess/tensor/Trabajo grpal/TODOS_LOS_MODELOS/tfjs-models/deeplab/src/types.ts"],"map":"{\"version\":3,\"file\":\"utils.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/utils.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"C:/Users/Alan Bonnet/Desktop/Clasess/tensor/Trabajo grpal/TODOS_LOS_MODELOS/tfjs-models/deeplab/utils.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport * as tf from '@tensorflow/tfjs-core';\r\nimport { Color, DeepLabInput, ModelArchitecture, QuantizationBytes, SegmentationData } from './types';\r\nexport declare function createPascalColormap(): Color[];\r\n/**\r\n * Returns\r\n *\r\n * @param base  :: `ModelArchitecture`\r\n *\r\n * The type of model to load (either `pascal`, `cityscapes` or `ade20k`).\r\n *\r\n * @param quantizationBytes (optional) :: `QuantizationBytes`\r\n *\r\n * The degree to which weights are quantized (either 1, 2 or 4).\r\n * Setting this attribute to 1 or 2 will load the model with int32 and\r\n * float32 compressed to 1 or 2 bytes respectively.\r\n * Set it to 4 to disable quantization.\r\n *\r\n * @return The URL of the TF.js model\r\n */\r\nexport declare function getURL(base: ModelArchitecture, quantizationBytes: QuantizationBytes): string;\r\n/**\r\n * @param base  :: `ModelArchitecture`\r\n *\r\n * The type of model to load (either `pascal`, `cityscapes` or `ade20k`).\r\n *\r\n * @return colormap :: `[number, number, number][]`\r\n *\r\n * The list of colors in RGB format, represented as arrays and corresponding\r\n * to labels.\r\n */\r\nexport declare function getColormap(base: ModelArchitecture): Color[];\r\n/**\r\n * @param base  :: `ModelArchitecture`\r\n *\r\n * The type of model to load (either `pascal`, `cityscapes` or `ade20k`).\r\n *\r\n * @return labellingScheme :: `string[]`\r\n *\r\n * The list with verbal descriptions of labels\r\n */\r\nexport declare function getLabels(base: ModelArchitecture): string[];\r\n/**\r\n * @param input  ::\r\n * `ImageData|HTMLImageElement|HTMLCanvasElement| HTMLVideoElement|tf.Tensor3D`\r\n *\r\n * The input image to prepare for segmentation.\r\n *\r\n * @return resizedInput :: `string[]`\r\n *\r\n * The input tensor to run through the model.\r\n */\r\nexport declare function toInputTensor(input: DeepLabInput): tf.Tensor<tf.Rank>;\r\n/**\r\n * @param colormap :: `Color[]`\r\n *\r\n * The list of colors in RGB format, represented as arrays and corresponding\r\n * to labels.\r\n *\r\n * @param labellingScheme :: `string[]`\r\n *\r\n * The list with verbal descriptions of labels\r\n *\r\n * @param rawSegmentationMap :: `tf.Tensor2D`\r\n *\r\n * The segmentation map of the image\r\n *\r\n * @param canvas (optional) :: `HTMLCanvasElement`\r\n *\r\n * The canvas where to draw the output\r\n *\r\n * @returns A promise of a `DeepLabOutput` object, with four attributes:\r\n *\r\n * - **legend** :: `{ [name: string]: [number, number, number] }`\r\n *\r\n *   The legend is a dictionary of objects recognized in the image and their\r\n *   colors in RGB format.\r\n *\r\n * - **height** :: `number`\r\n *\r\n *   The height of the returned segmentation map\r\n *\r\n * - **width** :: `number`\r\n *\r\n *   The width of the returned segmentation map\r\n *\r\n * - **segmentationMap** :: `Uint8ClampedArray`\r\n *\r\n *   The colored segmentation map as `Uint8ClampedArray` which can be\r\n *   fed into `ImageData` and mapped to a canvas.\r\n */\r\nexport declare function toSegmentationImage(colormap: Color[], labelNames: string[], rawSegmentationMap: tf.Tensor2D, canvas?: HTMLCanvasElement): Promise<SegmentationData>;\r\n"}}
